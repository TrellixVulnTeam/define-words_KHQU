"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBackend = exports.resolveBackend = exports.of = exports.empty = void 0;
const backend = require("./backend");
const proto = require("../../gcp/proto");
const api = require("../../.../../api");
const params = require("./params");
const previews_1 = require("../../previews");
const error_1 = require("../../error");
const functional_1 = require("../../functional");
const logger_1 = require("../../logger");
function empty() {
    return {
        requiredAPIs: [],
        endpoints: {},
        params: [],
    };
}
exports.empty = empty;
function of(endpoints) {
    const build = empty();
    build.endpoints = endpoints;
    return build;
}
exports.of = of;
async function resolveBackend(build, userEnvOpt, userEnvs) {
    const projectId = userEnvOpt.projectId;
    let paramValues = {};
    if (previews_1.previews.functionsparams) {
        paramValues = await params.resolveParams(build.params, projectId, userEnvs);
    }
    return toBackend(build, paramValues);
}
exports.resolveBackend = resolveBackend;
class Resolver {
    constructor(paramValues) {
        this.paramValues = paramValues;
        this.resolveInt = (i) => {
            if (i === null) {
                return i;
            }
            return params.resolveInt(i, this.paramValues);
        };
        this.resolveBoolean = (i) => {
            if (i === null) {
                return i;
            }
            return params.resolveBoolean(i, this.paramValues);
        };
        this.resolveString = (i) => {
            if (i === null) {
                return i;
            }
            return params.resolveString(i, this.paramValues);
        };
    }
    resolveStrings(dest, src, ...keys) {
        for (const key of keys) {
            const orig = src[key];
            if (typeof orig === "undefined") {
                continue;
            }
            dest[key] = orig === null ? null : params.resolveString(orig, this.paramValues);
        }
    }
    resolveInts(dest, src, ...keys) {
        for (const key of keys) {
            const orig = src[key];
            if (typeof orig === "undefined") {
                continue;
            }
            dest[key] = orig === null ? null : params.resolveInt(orig, this.paramValues);
        }
    }
}
function toBackend(build, paramValues) {
    const r = new Resolver(paramValues);
    const bkEndpoints = [];
    for (const endpointId of Object.keys(build.endpoints)) {
        const bdEndpoint = build.endpoints[endpointId];
        let regions = bdEndpoint.region;
        if (typeof regions === "undefined") {
            regions = [api.functionsDefaultRegion];
        }
        for (const region of regions) {
            const trigger = discoverTrigger(bdEndpoint, region, r);
            if (typeof bdEndpoint.platform === "undefined") {
                throw new error_1.FirebaseError("platform can't be undefined");
            }
            if (bdEndpoint.availableMemoryMb != null &&
                !backend.isValidMemoryOption(bdEndpoint.availableMemoryMb)) {
                throw new error_1.FirebaseError("available memory must be a supported value, if present");
            }
            const bkEndpoint = Object.assign({ id: endpointId, project: bdEndpoint.project, region: region, entryPoint: bdEndpoint.entryPoint, platform: bdEndpoint.platform, runtime: bdEndpoint.runtime }, trigger);
            proto.copyIfPresent(bkEndpoint, bdEndpoint, "environmentVariables", "labels", "secretEnvironmentVariables", "serviceAccount");
            proto.convertIfPresent(bkEndpoint, bdEndpoint, "ingressSettings", (from) => {
                if (from !== null && !backend.AllIngressSettings.includes(from)) {
                    throw new error_1.FirebaseError(`Cannot set ingress settings to invalid value ${from}`);
                }
                return from;
            });
            proto.convertIfPresent(bkEndpoint, bdEndpoint, "availableMemoryMb", (from) => {
                const mem = r.resolveInt(from);
                if (mem !== null && !backend.isValidMemoryOption(mem)) {
                    logger_1.logger.debug("Warning; setting memory to unexpected value", mem);
                }
                return mem;
            });
            r.resolveInts(bkEndpoint, bdEndpoint, "timeoutSeconds", "maxInstances", "minInstances", "concurrency");
            proto.convertIfPresent(bkEndpoint, bdEndpoint, "cpu", (0, functional_1.nullsafeVisitor)((cpu) => (cpu === "gcf_gen1" ? cpu : r.resolveInt(cpu))));
            if (bdEndpoint.vpc) {
                if (bdEndpoint.vpc.connector && !bdEndpoint.vpc.connector.includes("/")) {
                    bdEndpoint.vpc.connector = `projects/${bdEndpoint.project}/locations/${region}/connectors/${bdEndpoint.vpc.connector}`;
                }
                bkEndpoint.vpc = { connector: params.resolveString(bdEndpoint.vpc.connector, paramValues) };
                proto.copyIfPresent(bkEndpoint.vpc, bdEndpoint.vpc, "egressSettings");
            }
            else if (bdEndpoint.vpc === null) {
                bkEndpoint.vpc = null;
            }
            bkEndpoints.push(bkEndpoint);
        }
    }
    const bkend = backend.of(...bkEndpoints);
    bkend.requiredAPIs = build.requiredAPIs;
    return bkend;
}
exports.toBackend = toBackend;
function discoverTrigger(endpoint, region, r) {
    if ("httpsTrigger" in endpoint) {
        const httpsTrigger = {};
        if (endpoint.httpsTrigger.invoker === null) {
            httpsTrigger.invoker = null;
        }
        else if (typeof endpoint.httpsTrigger.invoker !== "undefined") {
            httpsTrigger.invoker = endpoint.httpsTrigger.invoker.map(r.resolveString);
        }
        return { httpsTrigger };
    }
    else if ("callableTrigger" in endpoint) {
        return { callableTrigger: {} };
    }
    else if ("blockingTrigger" in endpoint) {
        return { blockingTrigger: endpoint.blockingTrigger };
    }
    else if ("eventTrigger" in endpoint) {
        const eventTrigger = {
            eventType: endpoint.eventTrigger.eventType,
            retry: r.resolveBoolean(endpoint.eventTrigger.retry) || false,
        };
        if (endpoint.eventTrigger.eventFilters) {
            eventTrigger.eventFilters = (0, functional_1.mapObject)(endpoint.eventTrigger.eventFilters, r.resolveString);
        }
        if (endpoint.eventTrigger.eventFilterPathPatterns) {
            eventTrigger.eventFilterPathPatterns = (0, functional_1.mapObject)(endpoint.eventTrigger.eventFilterPathPatterns, r.resolveString);
        }
        r.resolveStrings(eventTrigger, endpoint.eventTrigger, "serviceAccount", "region", "channel");
        return { eventTrigger };
    }
    else if ("scheduleTrigger" in endpoint) {
        const bkSchedule = {
            schedule: r.resolveString(endpoint.scheduleTrigger.schedule),
            timeZone: r.resolveString(endpoint.scheduleTrigger.timeZone),
        };
        if (endpoint.scheduleTrigger.retryConfig) {
            const bkRetry = {};
            r.resolveInts(bkRetry, endpoint.scheduleTrigger.retryConfig, "maxBackoffSeconds", "minBackoffSeconds", "maxRetrySeconds", "retryCount", "maxDoublings");
            bkSchedule.retryConfig = bkRetry;
        }
        else if (endpoint.scheduleTrigger.retryConfig === null) {
            bkSchedule.retryConfig = null;
        }
        return { scheduleTrigger: bkSchedule };
    }
    else if ("taskQueueTrigger" in endpoint) {
        const taskQueueTrigger = {};
        if (endpoint.taskQueueTrigger.rateLimits) {
            taskQueueTrigger.rateLimits = {};
            r.resolveInts(taskQueueTrigger.rateLimits, endpoint.taskQueueTrigger.rateLimits, "maxConcurrentDispatches", "maxDispatchesPerSecond");
        }
        else if (endpoint.taskQueueTrigger.rateLimits === null) {
            taskQueueTrigger.rateLimits = null;
        }
        if (endpoint.taskQueueTrigger.retryConfig) {
            taskQueueTrigger.retryConfig = {};
            r.resolveInts(taskQueueTrigger.retryConfig, endpoint.taskQueueTrigger.retryConfig, "maxAttempts", "maxBackoffSeconds", "minBackoffSeconds", "maxRetrySeconds", "maxDoublings");
        }
        else if (endpoint.taskQueueTrigger.retryConfig === null) {
            taskQueueTrigger.retryConfig = null;
        }
        if (endpoint.taskQueueTrigger.invoker) {
            taskQueueTrigger.invoker = endpoint.taskQueueTrigger.invoker.map(r.resolveString);
        }
        else if (endpoint.taskQueueTrigger.invoker === null) {
            taskQueueTrigger.invoker = null;
        }
        return { taskQueueTrigger };
    }
    (0, functional_1.assertExhaustive)(endpoint);
}
